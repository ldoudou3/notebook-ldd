# 开发前分析
1. 消息格式：支持数组遍历（devices、services）
	1. 消息中devices和services是数组结构，因此一条消息中可能含有多个devices、一个devices中可能有多条services的数据。
	2. {
		  "devices": [{          // 数组结构
		    "deviceId": "...",
		    "services": [{       // 数组结构
			      "serviceId": "fileTransfer",
			      "data": {...},
			      "eventTime": "..."
		    }]
		  }]
		}

2. ORM：MyBatis-Plus

3. ~~Redis：在 docker-compose 中添加 Redis 服务~~
	1. 因为单节点消费，不存在跨节点协调，也不是高并发任务队列，用内存缓存即可

4. 数据库：使用与 backend 相同的连接

5. 连接池：默认 HikariCP

6. 幂等性：deviceId + eventTime + serviceId
	1. 如果使用主流 MQ（Kafka/RabbitMQ/RocketMQ/MQTT），都遵循”至少投递一次“，也就是会出出现重复的信息
	2. 因此绝大多数情况下都需要幂等

7. 批量处理：不批量，逐条处理
	1. 减少数据库的交互次数
	2. 数据库连接开销更小
	3. 事务一致性：同一消息的数据可以在一个事务中处理

8. 文件大小：最大 5KB

9. 错误处理：失败返回 false 重试，记录到应用日志

10. MD5 校验失败：记录日志并返回错误

11. 华为 MQS是推模式（push-based）消费模型，服务端主动推送消息到客户端，客户端通过监听器处理。

12. 处理逻辑
		收到分片
	    ↓
		判断 messageId 是否已处理（幂等）
	    ↓
		缓存分片（HashMap 或本地文件）
	    ↓
		判断分片是否全部到齐
	    ↓
		否 → 返回 CONSUME_SUCCESS（不用失败，等下一片到来）
	    ↓
		是 → 拼接文件
	    ↓
		写入数据库
	    ↓
		成功 → 返回 CONSUME_SUCCESS
		失败 → 返回 RECONSUME_LATER（MQS 自动重试）

13. MQS 推送模式下的消息传输失败
	1. 消息传输失败（消息没传到消费者）
		1. MQS本身负责：消息持久化、断线重连、