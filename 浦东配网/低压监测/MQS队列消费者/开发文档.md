# 开发前分析
1. 消息格式：支持数组遍历（devices、services）
	1. 消息中devices和services是数组结构，因此一条消息中可能含有多个devices、一个devices中可能有多条services的数据。
	2. {
		  "devices": [{          // 数组结构
		    "deviceId": "...",
		    "services": [{       // 数组结构
			      "serviceId": "fileTransfer",
			      "data": {...},
			      "eventTime": "..."
		    }]
		  }]
		}
	3. 消息解析
		1. 按 message 解析 → 遍历 devices → 再遍历 services → 按 serviceId 分类处理。
		2. MQ 推来消息
			   ↓
			解析 JSON → 得到 devices[]
			   ↓
			for 每个 device:
			    for 每个 service:
			        switch(serviceId):
			             discreteData → 状态量处理
			             analogData   → 模拟量处理
			             fileTransfer → 文件处理

		

2. 技术栈
	1. 框架：Spring Boot 2.7.18
	2. JDK：JDK 8
	3. ORM：MyBatis-Plus
	4. 数据库：MySQL 8.0
	5. 消息队列：华为 MQS（基于 RocketMQ）
	6. 缓存：内存缓存（ConcurrentHashMap）
	7. JSON解析：FastJSON 1.2.56
	8. ORM：MyBatis-Plus
	9. 连接池：默认 HikariCP


3. ~~Redis：在 docker-compose 中添加 Redis 服务~~
	1. 因为单节点消费，不存在跨节点协调，也不是高并发任务队列，用内存缓存即可

4. 数据库：使用与 backend 相同的连接

5. 幂等性：deviceId + eventTime + serviceId
	1. 如果使用主流 MQ（Kafka/RabbitMQ/RocketMQ/MQTT），都遵循”至少投递一次“，也就是会出出现重复的信息
	2. 因此绝大多数情况下都需要幂等
	3. 单节点采用内存 HashSet / Map即可。

6. **模拟量和状态量处理**： 批量处理
	1. 减少数据库的交互次数
	2. 数据库连接开销更小
	3. 事务一致性：同一消息的数据可以在一个事务中处理

7. **文件处理：** 
	1. 分片缓存
		1. 保证重试时不会冲掉之前的数据
		2. Map<String, FileMergeBuffer> bufferMap;
		3. 一个filemergebuffer包含
			1. 已经收到的分片数量
			2. 每片的内容 
			3. 文件的总分片数
			4. 是否已经处理完成
			5. 上次收到的分片时间
	2. 分片超时处理
		1. 超过十分钟就丢弃
		2. 清理buffer
		3. 记录日志
		4. 通知上游

8. 文件大小：最大 5KB

9. 错误处理：失败返回 false 重试，记录到应用日志

10. MD5 校验失败：记录日志并返回错误

11. 华为 MQS是推模式（push-based）消费模型，服务端主动推送消息到客户端，客户端通过监听器处理。

12. 处理逻辑：
	1. 按 message 解析 → 遍历 devices → 再遍历 services → 按 serviceId 分类处理。
		收到分片
	    ↓
		判断 messageId 是否已处理（幂等）
	    ↓
		缓存分片（HashMap 或本地文件）
	    ↓
		判断分片是否全部到齐
	    ↓
		否 → 返回 CONSUME_SUCCESS（不用失败，等下一片到来）
	    ↓
		是 → 拼接文件
	    ↓
		写入数据库
	    ↓
		成功 → 返回 CONSUME_SUCCESS
		失败 → 返回 RECONSUME_LATER（MQS 自动重试）

13. MQS 推送模式下的消息传输失败
	1. 消息传输失败（消息没传到消费者）
		1. MQS本身负责：消息持久化、断线重连、消息重传等
	2. 消息传到消费者系统，处理失败
		1. 返回ConsumeStatus.RECONSUME_LATER，MQS会自动重新投递此条消息。

14. 物管平台给的时间YYYYMMDDTHHMMSSZ，是UTC时间字符串格式，需要转换为本地时区（+8），以及调整格式为数据库中适配的"yyyy-MM-dd HH:mm:ss"。


# 开发中
1. 还不能连接物管平台，因此实现一个接口来测试模拟量数据和录波文件能否正常接收
	1. 测试证明能够正常接收！
2. 现场开发遇到的问题和总结：
	1. mqs的JDK版本不对：
		1. 重新下载并mvn -DskipTests package打包新的可执行文件jar；
		2. 在根目录重新构建镜像
			1. sudo DOCKER_BUILDKIT=0 docker compose build mqs-consumer ：优先使用本地已有的JDK镜像来构建镜像。 
			2. sudo ./export_images.sh 得到离线部署包，将新的mqs的tar复制到机子中就行。
	2. 如何测试mqs模块
		1. 
		2. /test/message接口测试模块接收数据后的处理能力。



# 验收后新需求
1. 5分钟作为一个时间节点，只插入整点数据，整点间的数据作为增量数据进行更新。✅
	1. 会有并发问题，需要处理：
		
		场景：同一窗口的多条消息并发到达
		
		消息A：eventTime=16:35:10 → 对齐到16:35:00
		
		消息B：eventTime=16:35:20 → 对齐到16:35:00

		两者可能同时尝试插入(device_id, 16:35:00)的记录

		解决方案：
		
> [!NOTE] Title
>1. 使用数据库唯一索引(device_id, event_time)
>2. 使用saveOrUpdate：先尝试插入，如果唯一索引冲突则更新
> 	这是一种 **Upsert (Update or Insert)** 策略
		    1. 程序尝试插入记录。
		    2. 如果插入成功，说明这是该窗口的第一条数据。
		    3. 如果插入失败（触发了唯一索引冲突），程序不报错，而是转而执行 `UPDATE` 操作，将当前消息的数据更新到已存在的记录中。
		MyBatis-Plus 提供的 `saveOrUpdate` 方法封装了上述逻辑。
		
		
			

		
2. 