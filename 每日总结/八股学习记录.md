# 原码、反码、补码与 IEEE754
##整数的表示：补码
1. 现在计算机中所有有符号整数都使用补码存储；
2. 原理：
	1. 在 $N$ 位的二进制系统中，减去一个数等于加上这个数的补数。
3. 生成：
	1. 【正数的原、反、补都一致；
	2. ｜X｜的原码；
	3. 反码：将原码除了符号位外每一位都取反；
	4. 补码：反码+1
	5. ｜**表示形式**|**+1 (8-bit)**|**−1 (8-bit)**|
		|**原码**|`0000 0001`|`1000 0001`|
		|**反码**|`0000 0001`|`1111 1110`|
		|**补码**|`0000 0001`|`1111 1111`|
	
	6. 补码 -- 》 原码
		1. 正数：不变
		2. 负数：取反码（符号位 $1$ 不动，数值位取反），再+1.
		

4. 优点
	1. 统一了加法运算
	2. 唯一的零表示
		1. 原码：0000 和 1000
		2. 反码：0000 和 1000
		3. 补码：只有0000
	3. 多一位负数

## 浮点数的表示：IEEE754
1. 为什么浮点数运算（如 $0.1 + 0.2$）在计算机中往往不等于 $0.3$？
	1. 原理：计算机内部是二进制，大部分十进制小数（如 $0.1$ 和 $0.2$）无法被**精确地**表示为有限长度的二进制小数。
	2. 解决方案：使用 **定点数**（如 Java 的 `BigDecimal` 或 Go 的第三方高精度库）或**整数**（将金额单位转换为分）。
2. 大端序和小端序
	1. 解释字节序在内存中的存放顺序
	2. 大：高位字节在内存的低地址（像阅读习惯，从左到右）
	3. 小：（Intel、AMD、x86）
	4. TCP/IP 中规定网络字节序为大端序。