# 原码、反码、补码与 IEEE754
##整数的表示：补码
1. 现在计算机中所有有符号整数都使用补码存储；
2. 原理：
	1. 在 $N$ 位的二进制系统中，减去一个数等于加上这个数的补数。
3. 生成：
	1. 【正数的原、反、补都一致；
	2. ｜X｜的原码；
	3. 反码：将原码除了符号位外每一位都取反；
	4. 补码：反码+1
	5. ｜**表示形式**|**+1 (8-bit)**|**−1 (8-bit)**|
		|**原码**|`0000 0001`|`1000 0001`|
		|**反码**|`0000 0001`|`1111 1110`|
		|**补码**|`0000 0001`|`1111 1111`|
	
	6. 补码 -- 》 原码
		1. 正数：不变
		2. 负数：取反码（符号位 $1$ 不动，数值位取反），再+1.
		

4. 优点
	1. 统一了加法运算
	2. 唯一的零表示
		1. 原码：0000 和 1000
		2. 反码：0000 和 1000
		3. 补码：只有0000
	3. 多一位负数

## 浮点数的表示：IEEE754
1. 为什么浮点数运算（如 $0.1 + 0.2$）在计算机中往往不等于 $0.3$？
	1. 原理：计算机内部是二进制，大部分十进制小数（如 $0.1$ 和 $0.2$）无法被**精确地**表示为有限长度的二进制小数。
	2. 解决方案：使用 **定点数**（如 Java 的 `BigDecimal` 或 Go 的第三方高精度库）或**整数**（将金额单位转换为分）。
2. 大端序和小端序
	1. 解释字节序在内存中的存放顺序
	2. 大：高位字节在内存的低地址（像阅读习惯，从左到右）
	3. 小：（Intel、AMD、x86）
	4. TCP/IP 中规定网络字节序为大端序。

# Nginx
1. nginx的作用
	1. 反向代理：在高并发场景，可以在多个服务器上部署后端，前端发来的所有请求，经过nginx，负载均衡的分发给不同的后端。
	2. 网关：日志、压缩、限流、自定义
2. 实现 nginx.conf中定义
3. 单线程
	1. 用单线程来处理所有的网络连接，解决了并发问题；
4. 多进程
	1. 又称为worker进程
	2. 一个进程中有一个线程
	3. 多进程共享一个共享内存和磁盘弓箭（proxy cache）
5. 总结
	1. 支持动态配置
	2. 支持多种通用网关能力
	3. 支持多种网络协议
	4. 单master、多worker架构
	5. 对外提供一个ip端口
	6. 支持http服务和反向代理的高性能网关服务
6. 示例
	server {
	    listen 80;
	    server_name localhost;
	    root /usr/share/nginx/html;
	    index index.html;
	    # 前端路由支持
	    location / {
	        try_files $uri $uri/ /index.html;
	    }
	    # API代理到后端
	    location /api/ {
	        proxy_pass http://backend:8080/;
	        proxy_set_header Host $host;
	        proxy_set_header X-Real-IP $remote_addr;
	        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
	        proxy_set_header X-Forwarded-Proto $scheme;
	    }
	    # 静态资源缓存
	    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
	        expires 1y;
	        add_header Cache-Control "public, immutable";
	    }
	}


# redis
1. 高性能的**内存**数据库，常用于缓存、分布式锁、消息队列等，是后端最常用的中间件之一。
2. 全称：remote dictionary server 远程字典服务
3. **超高速** （亚毫秒级，全内存操作，是mysql的100~1000倍速度）的
4. **键值** （key-value：多种数据结构)数据库 
5. redis连接池
	1. 一组提前创建好的redis连接，由框架进行统一管理和复用；
	2. 避免频繁创建redis连接，提高性能。 


# 一些指令
## telnet
建立TCP连接，连接成功后进入纯文本交互模式
```
telnet 192.168.124.62 8602
或者
nc -vz 25.45.68.185 9776
```

## netstat -lnto
查看本机有哪些服务、这些服务在监听哪些端口

```
netstat -lntp
或者
ss -lntp

返回结果中：
- **Local Address 是服务窗口的位置**  
    （窗口开在 127.0.0.1 上，就只有柜台内部的人能使用；开在 0.0.0.0 上，大家都能过来）
    
- **Peer Address 是来访人的位置**  
    （监听状态下没人来，所以显示 `*`）
```

## ps -ef
查看当前系统中正在运行的进程

## route -n
查看当前系统的路由表
```
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref Use Iface
0.0.0.0         192.168.124.1   0.0.0.0         UG    100    0   0   wlan0
192.168.124.0   0.0.0.0         255.255.255.0   U     600    0   0   wlan0
```
Destination：目标网段
Gateway：下一跳的网关
Genmask：子网掩码 
Iface：经过哪一个网卡


# 进程与线程
## 进程（process）
1. 操作系统进行资源分配和调度的基本单位
2. 核心特性
	1. 拥有独立的地址空间（内存），独立的文件描述符、独立的io通道等；
	2. 进程之间通信成本高，需要内核支持（管道、消息队列、共享内存），进行上下文切换
	3. 健壮性：一个进程奔溃不影响别的进程。
## 线程（thread）
1. CPU独立调度和执行的基本单位
2. 核心特性
	1. 同一进程中的所有线程共享地址空间、文件描述符等资源，是线程高效通信的基础。
	2. 线程之间通信只需要读写共享内存中的数据，很高效。
	3. 线程的创建、销毁和切换只需要对寄存器进行简单的恢复和保存，开销远小于进程。
	4. 多任务并发/并行的核心手段。
3. Executor 框架与线程池
	1. Java 最核心的线程管理机制是 `java.util.concurrent.Executor` 框架。
	2. 任务提交（用户）与线程执行（框架）的解耦；
```java
// 线程池初始化，线程池维护了4个保持alive的工作线程。
private static final ExecutorService executor = Executors.newFixedThreadPool(4);
// 任务提交，线程池查看是否有空闲线程，如果有就将这个任务分配给空闲线程；如果没有，任务就会被放入阻塞队列，等待线程来执行。
executor.execute(() -> { ... })


// 提交一个 Runnable 任务给线程池 
executor.execute(() -> { 
System.out.printf("线程 %s 正在处理任务 %d\n", Thread.currentThread().getName(), taskId); 
try { // 模拟耗时操作，如 I/O 或发送邮件 TimeUnit.MILLISECONDS.sleep(100); } 
catch (InterruptedException e) { Thread.currentThread().interrupt();
} 
});

//1. 定义一个 Callable 任务，它可以返回一个结果并抛出异常 
Callable<Integer> calculationTask = () -> { System.out.println("开始计算..."); TimeUnit.SECONDS.sleep(2); return 10 + 20; // 返回计算结果 30 
}; 
// 2. 提交任务并得到 Future 对象 
Future<Integer> futureResult = executor.submit(calculationTask);
```
### 用户级线程(User-Level Thread, ULT)
线程的创建、管理、调度、切换完全在**用户空间**中进行；
### 内核级线程(Kernel-Level Thread, KLT)
线程的管理、创建、调度和切换**全部**由**操作系统内核**完成和控制。


## 文件描述符（File Descriptor, FD）
1. ”一切皆文件“：系统将打开的文件、套接字（TC)、io资源等皆看作文件；
2. 文件描述符是操作系统为了管理这些 ”文件“ 而创建的一个非负整数句柄，是进程访问这些 ”文件“ 的唯一标识；
3. 每个进程有自己独立的文件描述符表；
4. 句柄作用：当进程调用 `open()`、`socket()` 等系统调用打开资源时，内核会返回一个 FD。进程后续对该资源的读写、控制等操作都通过这个 FD 进行；
5. 每个FD对应内核维护的一个数据结构，这个结构包含了文件的当前读写位置、访问模式、引用计数等关键信息。
6. 操作系统对单个进程能打开的FD有上限，ulimit -n可查看。

****

# 并发和并行
## 并发
宏观上多任务同时进行，微观上在单核cpu多任务在交替执行

## 并行
多任务在同一时刻在多核cpu上真正的同时进行

# git
工作区开发-->修改后的文件添加到暂存区-->将暂存区文件记录到版本库
工作区：电脑中看到的
暂存区：.git文件夹内的index二进制
本地git仓库：
远程git仓库：
[M:modified、A:added、D:deleted、R:renamed、C:copied、U:update but unmerged]
```bash
git init  # 初始化空的仓库
git add ./index.html/css/... # 添加工作区变化到暂存区
git commit -m "" # 把暂存区的内容提交到本地版本库
git remote add origin[仓库别名] 仓库地址 # 给本地git仓库配置远程仓库地址
git remote set-url origin[仓库别名] 新仓库地址 # 给本地git仓库配置新的远程仓库地址
git push -u origin[仓库别名] master[分支名] # 第一次推送到远程，要加上分支名
git push # 后续只需要push

git log
git log --oneline
git reset --hard 版本号 # 回退到某次记录
git checkout -b reg[新分支名] # 创建新分支
git checkout reg # 切换到reg分支
git checkout master, git merge reg # 把reg分支的内容合并到master
git branch reg # 以当前节点为基准创建分支reg，包含之前所有的提交记录 
git rm -r --cached mqs-consumer/target # 如果文件夹已经被git跟踪，先将其移除
```


# 序列化和反序列化
- 序列化：将对象或者数据结构转化为可以存储或者传输的格式（字节流、json、xml等）
- 反序列化：将序列化后的数据还原。