# 原码、反码、补码与 IEEE754
##整数的表示：补码
1. 现在计算机中所有有符号整数都使用补码存储；
2. 原理：
	1. 在 $N$ 位的二进制系统中，减去一个数等于加上这个数的补数。
3. 生成：
	1. 【正数的原、反、补都一致；
	2. ｜X｜的原码；
	3. 反码：将原码除了符号位外每一位都取反；
	4. 补码：反码+1
	5. ｜**表示形式**|**+1 (8-bit)**|**−1 (8-bit)**|
		|**原码**|`0000 0001`|`1000 0001`|
		|**反码**|`0000 0001`|`1111 1110`|
		|**补码**|`0000 0001`|`1111 1111`|
	
	6. 补码 -- 》 原码
		1. 正数：不变
		2. 负数：取反码（符号位 $1$ 不动，数值位取反），再+1.
		

4. 优点
	1. 统一了加法运算
	2. 唯一的零表示
		1. 原码：0000 和 1000
		2. 反码：0000 和 1000
		3. 补码：只有0000
	3. 多一位负数

## 浮点数的表示：IEEE754
1. 为什么浮点数运算（如 $0.1 + 0.2$）在计算机中往往不等于 $0.3$？
	1. 原理：计算机内部是二进制，大部分十进制小数（如 $0.1$ 和 $0.2$）无法被**精确地**表示为有限长度的二进制小数。
	2. 解决方案：使用 **定点数**（如 Java 的 `BigDecimal` 或 Go 的第三方高精度库）或**整数**（将金额单位转换为分）。
2. 大端序和小端序
	1. 解释字节序在内存中的存放顺序
	2. 大：高位字节在内存的低地址（像阅读习惯，从左到右）
	3. 小：（Intel、AMD、x86）
	4. TCP/IP 中规定网络字节序为大端序。

# Nginx
1. nginx的作用
	1. 反向代理：在高并发场景，可以在多个服务器上部署后端，前端发来的所有请求，经过nginx，负载均衡的分发给不同的后端。
	2. 网关：日志、压缩、限流、自定义
2. 实现 nginx.conf中定义
3. 单线程
	1. 用单线程来处理所有的网络连接，解决了并发问题；
4. 多进程
	1. 又称为worker进程
	2. 一个进程中有一个线程
	3. 多进程共享一个共享内存和磁盘弓箭（proxy cache）
5. 总结
	1. 支持动态配置
	2. 支持多种通用网关能力
	3. 支持多种网络协议
	4. 单master、多worker架构
	5. 对外提供一个ip端口
	6. 支持http服务和反向代理的高性能网关服务
6. 示例
	server {
	    listen 80;
	    server_name localhost;
	    root /usr/share/nginx/html;
	    index index.html;
	    # 前端路由支持
	    location / {
	        try_files $uri $uri/ /index.html;
	    }
	    # API代理到后端
	    location /api/ {
	        proxy_pass http://backend:8080/;
	        proxy_set_header Host $host;
	        proxy_set_header X-Real-IP $remote_addr;
	        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
	        proxy_set_header X-Forwarded-Proto $scheme;
	    }
	    # 静态资源缓存
	    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
	        expires 1y;
	        add_header Cache-Control "public, immutable";
	    }
	}


# redis
1. 高性能的**内存**数据库，常用于缓存、分布式锁、消息队列等，是后端最常用的中间件之一。
2. 全称：remote dictionary server 远程字典服务
3. **超高速** （亚毫秒级，全内存操作，是mysql的100~1000倍速度）的
4. **键值** （key-value：多种数据结构)数据库 
5. redis连接池
	1. 一组提前创建好的redis连接，由框架进行统一管理和复用；
	2. 避免频繁创建redis连接，提高性能。 


# telnet
建立TCP连接，连接成功后进入纯文本交互模式
```
telnet 192.168.124.62 8602
或者
nc -vz 25.45.68.185 9776
```

# netstat -lnto
查看本机有哪些服务、这些服务在监听哪些端口

```
telnet -lntp
或者
ss -lntp

返回结果中：
- **Local Address 是服务窗口的位置**  
    （窗口开在 127.0.0.1 上，就只有柜台内部的人能使用；开在 0.0.0.0 上，大家都能过来）
    
- **Peer Address 是来访人的位置**  
    （监听状态下没人来，所以显示 `*`）
```
