# 低压监测系统 - 项目整理


## I. 核心信息概览（项目卡片）— 30秒快速回忆

### A. 项目名称与定位

- **项目名称**：低压监测系统（DIYAJIANCE）

- **一句话概括**：基于==微服务架构==的实时设备监测与数据分析平台，从华为云MQS消费设备数据，提供实时监测、历史查询、预警分析和负荷预测功能

### B. 个人角色与时长

- **角色**：核心全栈开发工程师

- **主要职责**：

  - 负责MQS消息消费服务的架构设计与实现

  - 负责后端API服务的设计与开发

  - 负责前端核心功能模块开发

  - 负责系统性能优化与离线部署方案设计

### C. 技术栈（核心）

- **前端**：Vue 3.2.13 + TypeScript 5.8.3 + Element Plus 2.10.2 + ECharts 5.6.0 + Vite 6.3.5 + Pinia 3.0.3

- **后端**：Spring Boot 3.2.5 (JDK 17) + MyBatis-Plus 3.5.7 + SpringDoc OpenAPI

- **消息消费**：Spring Boot 2.7.18 (JDK 8) + 华为MQS SDK (基于RocketMQ)

- **预测服务**：Python + XGBoost + Flask

- **数据库**：MySQL 8.0

- **DevOps**：Docker + Docker Compose + Nginx + 离线部署方案

  
### D. 项目成果/价值

- **数据处理能力**：支持批量处理==100-200条/批次==，大幅减少数据库交互次数

- **文件传输可靠性**：==实现分帧传输与自动拼接==，文件完整性通过MD5校验保证

- **系统可用性**：支持离线部署，内网环境一键部署

- **查询性能**：通过==缓存策略和索引优化==，历史数据查询响应时间显著降低

  

---

  
## II. 项目背景与挑战

  
### 1. 业务痛点/背景

- **业务需求**：实时监测低压配电设备运行状态（电压、电流、功率等），及时发现异常并预警，支持负荷预测优化用电

- **核心价值**：提升设备运维效率，降低故障风险，支持数据驱动的运维决策


### 2. 技术挑战（重点）

  
#### 挑战1：文件分帧传输与拼接

- **问题**：录波文件通过MQS分帧传输，需要按序接收、拼接、校验

- **难点**：帧可能乱序到达、中间帧可能丢失，需要保证完整性与幂等性，避免内存泄漏

  
#### 挑战2：高并发数据写入

- **问题**：大量设备实时上报数据，需要高效批量写入数据库

- **难点**：平衡批量大小与处理延迟，保证数据一致性

  

#### 挑战3：跨服务通信与数据一致性

- **问题**：MQS Consumer、Backend、Prediction Service之间的数据流转

- **难点**：保证数据最终一致性，服务间解耦

  

#### 挑战4：离线部署

- **问题**：内网环境无法联网，需要完整离线部署方案

- **难点**：镜像导出、依赖管理、配置适配

  

### 3. 核心目标

- 实现实时数据采集与存储

- 提供高效的历史数据查询

- 支持设备预警与负荷预测

- 支持离线环境一键部署

  

---
  

## III. 深入技术细节（全栈展示）

### A. 后端/架构设计

  
#### 1. 整体架构

  

```

┌─────────────────┐

│   MQS 服务端    │ (华为云消息队列服务)

│  (数据源)       │

└────────┬────────┘

         │ 推送消息

         ↓

┌─────────────────┐

│  mqs-consumer   │ (JDK 8, Spring Boot 2.7.18)

│  消息消费者     │ 端口: 8081

└────────┬────────┘

         │ 存储数据

         ↓

┌─────────────────┐

│   MySQL 8.0     │ 端口: 3306

│   数据库        │

└────────┬────────┘

         │ 查询数据

         ↓

┌─────────────────┐

│    backend      │ (JDK 17, Spring Boot 3.2.5)

│   后端服务      │ 端口: 8080

└────────┬────────┘

         │ REST API

         ↓

┌─────────────────┐

│   frontend      │ (Vue 3 + TypeScript + Vite)

│   前端服务      │ 端口: 10001 (Nginx)

└─────────────────┘

         │

         ↓

┌─────────────────┐

│prediction-service│ (Python + XGBoost)

│   预测服务      │ 端口: 5000

└─────────────────┘

```

  

**架构特点**：

- 微服务架构，服务职责清晰

- 消息驱动，异步解耦

- 前后端分离，API统一管理

  

#### 2. 核心模块设计


##### 模块1：MQS消息消费服务（mqs-consumer）
  

**核心流程**：

```

MQS消息 → MqsClient → BatchMessageHandler →

  ├─→ DiscreteDataHandler (状态量处理器)

  ├─→ AnalogDataHandler (模拟量处理器)

  └─→ FileTransferHandler (文件传输处理器)

    ↓

  ├─→ DiscreteDataService (批量插入)

  ├─→ AnalogDataService (批量插入)

  └─→ WaveformFileService (文件存储)

```

  

**技术亮点**：


1. **批量处理优化**

   - 状态量/模拟量收集到批次，每批100-200条批量插入

   - 减少数据库交互次数，提升写入性能

   - 关键代码：`BatchMessageHandler.java`

  

2. **文件分帧缓存**

   - 使用`ConcurrentHashMap` + `TreeMap`实现线程安全的分帧缓存

   - 支持乱序接收，自动按帧序号排序拼接

   - 过期清理机制，避免内存泄漏

   - 关键代码：`FileFrameCache.java`

  

3. **幂等性保证**

   - 通过数据库唯一索引（`device_id + event_time + file_format`）保证文件传输幂等性

   - 状态量/模拟量通过应用层去重检查

  

4. **错误处理策略**

   - 状态量/模拟量失败：返回`false`，触发MQS重试

   - 文件传输失败：仅记录日志，不触发整条消息重试（避免帧数据丢失）

  

##### 模块2：后端API服务（backend）

  

**核心功能**：

- **设备管理**：设备CRUD、分组树形结构、设备搜索

- **历史数据查询**：支持多时间粒度（5分钟/小时/天）、多模拟量类型查询

- **设备预警**：基于当日最高电流占额定电流比例筛选预警设备

- **录波文件管理**：文件列表查询、文件访问路径获取

  

**技术亮点**：

  

1. **缓存策略**

   - 使用Spring Cache，设备列表缓存（`@Cacheable(value = "devices", key = "'all'")`）

   - 设备变更时自动清除缓存（`@CacheEvict`）

   - 最新数据缓存（`@Cacheable(value = "latestData", key = "#deviceId")`）

  

2. **统一响应格式**

   ```java

   ApiResponseDTO<T> {

       code: Integer,

       message: String,

       data: T,

       timestamp: LocalDateTime

   }

   ```

  

3. **API文档**

   - 集成SpringDoc OpenAPI，自动生成Swagger文档

   - 访问地址：`http://localhost:8080/swagger-ui.html`

  

#### 3. 数据存储与查询

  

**核心表结构**：

- `device_group`：设备分组表（支持树形结构）

- `device_info`：设备信息表（设备基础信息、额定电流等）

- `discrete_data`：状态量数据表（约30个字段，如开关状态、故障状态）

- `analog_data`：模拟量数据表（约60+个字段，如电压、电流、功率）

- `waveform_file`：录波文件表（存储完整文件二进制LONGBLOB）

  

**索引优化**：

- `discrete_data`：`idx_discrete_device_time (device_id, event_time)`

- `analog_data`：`idx_analog_device_time (device_id, event_time)`

- `waveform_file`：

  - `uk_file_device_time (device_id, event_time, file_format)` - 唯一索引

  - `idx_file_device_time (device_id, event_time)`

  - `idx_file_md5 (file_md5)`

  

**查询优化**：

- 历史数据查询使用时间范围索引，支持高效的时间序列查询

- 最新数据查询通过`ORDER BY event_time DESC LIMIT 1`，配合索引快速定位

  

#### 4. API设计

  

**设计规范**：

- RESTful风格：`GET /devices`、`POST /data/history_analog_data`

- 统一响应格式：`ApiResponseDTO<T>`

- 参数校验：使用`@Valid`注解进行请求参数校验

  

#### 5. 性能与可扩展性

  

**缓存策略**：

- **应用层缓存**：Spring Cache，缓存设备列表、最新数据

- **缓存键设计**：`devices::all`、`latestData::#{deviceId}`

- **缓存更新**：设备变更时自动清除相关缓存

  

**消息队列**：

- **MQS（基于RocketMQ）**：用于数据采集，实现数据源与系统的解耦

- **消费模式**：推送模式（Push），服务端主动推送消息

- **重试机制**：失败返回`RECONSUME_LATER`，最多重试16次

  

**高可用设计**：

- **数据库连接池**：HikariCP，优化连接管理

- **批量处理**：减少数据库交互，提升写入性能

- **错误隔离**：文件传输失败不影响状态量/模拟量处理

  

### B. 前端/用户体验

  

#### 1. 技术选型

  

**为什么选择Vue 3**：

- **Composition API**：更好的逻辑复用和代码组织

- **TypeScript支持**：类型安全，提升开发体验

- **生态成熟**：Element Plus、ECharts等组件库完善

- **性能优化**：Vue 3的响应式系统性能更优

  

#### 2. 核心组件与状态管理

  

**组件设计**：

- **可复用组件**：`AnalogHistoryChart`（历史数据图表）、`DataReport`（数据报表）

- **页面组件**：`DeviceDetail`（设备详情）、`DeviceWarning`（设备预警）

  

**状态管理**：

- **Pinia**：轻量级状态管理，替代Vuex

- **状态划分**：设备状态、用户状态、UI状态分离

  

#### 3. 性能优化

  

**已实现的优化**：

- **代码分割**：Vite自动代码分割，按路由懒加载

- **静态资源缓存**：Nginx配置静态资源1年缓存，`Cache-Control: public, immutable`

- **API请求优化**：并发查询多个字段，使用`Promise.all`并行处理

- **图表优化**：ECharts按需加载，大数据量时使用数据采样

  

#### 4. 交互设计

  

**用户体验优化**：

- **响应式布局**：支持不同屏幕尺寸

- **加载状态**：使用`el-skeleton`提供加载反馈

- **错误处理**：统一的错误提示，友好的错误信息

- **数据可视化**：ECharts图表，支持交互式数据探索

  

### C. DevOps与质量保障

  

#### 1. 部署流程

  

**Docker容器化**：

- **多阶段构建**：前端构建阶段 + Nginx运行阶段

- **镜像分层**：优化镜像大小，提升构建速度

- **环境变量配置**：通过环境变量管理配置

  

**离线部署方案**：

- **镜像导出**：`export-images.sh`脚本自动导出所有镜像

- **离线导入**：提供导入脚本，一键导入镜像

- **配置适配**：`docker-compose.offline.yml`适配离线环境

  

**部署流程**：

```bash

# 联网环境：构建镜像

docker compose build

  

# 导出镜像

./export-images.sh

  

# 离线环境：导入镜像

./import-images.sh

  

# 启动服务

docker compose -f docker-compose.offline.yml up -d

```

  

#### 2. 监控与日志

  

**日志管理**：

- **日志级别**：INFO级别记录关键操作，ERROR级别记录异常

- **日志内容**：消息处理结果、性能指标（处理耗时）、错误详情

- **日志位置**：应用日志文件，不写入数据库

  

**健康检查**：

- **预测服务**：`GET /health`接口，检查数据库连接状态

- **Docker健康检查**：容器级别的健康检查配置

  

---

  

## IV. 难点与解决方案（个人亮点）

  

### 1. 遇到的最大挑战

  

**挑战：文件分帧传输与自动拼接**

  

**问题描述**：

- 录波文件通过MQS分帧传输，每帧包含部分文件内容

- 帧可能乱序到达、中间帧可能丢失

- 需要保证文件完整性，支持MD5校验

- 需要避免内存泄漏（未完成的传输）

  

**技术难点**：

- 如何高效管理分帧缓存？

- 如何保证线程安全？

- 如何处理帧丢失/超时？

- 如何保证幂等性？

  

### 2. 解决方案（Action）

  

**方案设计**：

  

**步骤1：设计缓存结构**

- 使用`ConcurrentHashMap<String, FrameBuffer>`实现线程安全的缓存

- Key格式：`file_transfer:{deviceId}:{fileName}:{eventTime}`

- Value：`FrameBuffer`内部类，使用`TreeMap<Integer, byte[]>`有序存储帧数据

  

**步骤2：实现帧接收逻辑**

```java

// 关键代码：FileFrameCache.java

public Optional<FileTransferAggregate> append(String key, FileInfoPayload payload, byte[] content) {

    // 1. 清理过期缓存

    cleanupExpired();

    // 2. 获取或创建FrameBuffer（线程安全）

    FrameBuffer buffer = cache.compute(key, (k, existing) -> {

        if (existing == null || existing.isExpired(expireDuration)) {

            return new FrameBuffer(payload.getTotalFrames());

        }

        // 处理帧序号重置、总帧数变更等边界情况

        return existing;

    });

    // 3. 追加帧数据

    buffer.appendFrame(payload.getCurFrameIdx(), content, maxFileSize);

    // 4. 检查是否所有帧已就绪

    if (buffer.isReady()) {

        cache.remove(key);

        return Optional.of(buffer.buildAggregate());

    }

    return Optional.empty();

}

```

  

**步骤3：实现文件拼接**

- 使用`ByteArrayOutputStream`按帧序号顺序拼接

- `TreeMap`保证帧数据有序，拼接时直接遍历values

  

**步骤4：实现过期清理**

- 每次操作时清理过期缓存（`cleanupExpired()`）

- 过期时间：1小时（可配置）

- 避免内存泄漏

  

**步骤5：MD5校验**

- 接收最后一帧时获取MD5值

- 拼接完成后计算文件MD5

- 校验失败记录日志，清理缓存

  

**步骤6：错误处理策略**

- 文件传输失败不抛出异常，避免触发整条消息重试

- 记录详细错误日志，包含期望值和实际值

- 失败时自动清理缓存

  

### 3. 结果与影响（Result）

  

**量化改善**：

- **文件完整性**：通过MD5校验，文件完整性保证100%

- **内存管理**：过期清理机制，避免内存泄漏

- **线程安全**：使用`ConcurrentHashMap`和`TreeMap`，支持并发场景

- **错误隔离**：文件传输失败不影响其他数据处理

  

**技术价值**：

- 实现了可靠的文件分帧传输方案

- 可复用到其他需要分帧传输的场景

- 展示了并发编程和内存管理能力

  

### 4. 经验教训

  

**如果重来，我会**：

- **考虑使用Redis**：如果文件较大或并发量高，可以考虑使用Redis作为分布式缓存，支持多实例部署

- **增加监控指标**：记录文件传输成功率、平均传输时间等指标，便于问题排查

- **优化缓存策略**：可以考虑LRU淘汰策略，而不仅仅是过期清理

  

**学到的经验**：

- **并发安全的重要性**：在高并发场景下，线程安全是基础

- **内存管理**：缓存必须考虑过期和清理，避免内存泄漏

- **错误隔离**：不同业务场景需要不同的错误处理策略

  

---

  

## V. 总结与提炼（面试高光点）

  

### 1. 最值得骄傲的贡献

  

**文件分帧传输与自动拼接模块**

  

**贡献点**：

- **独立设计并实现**：从需求分析到方案设计，再到编码实现，全程主导

- **技术深度**：涉及并发编程、内存管理、数据结构设计等多个技术点

- **工程实践**：考虑了线程安全、内存泄漏、错误处理等工程问题

- **可复用性**：方案可复用到其他需要分帧传输的场景

  

**效果**：

- 实现了可靠的文件传输方案，文件完整性100%

- 支持高并发场景，线程安全

- 代码质量高，易于维护和扩展

  

### 2. 全栈能力的体现

  

**在这个项目中，我横跨前后端、架构、运维多个领域**：

  

**后端开发**：

- 设计并实现了MQS消息消费服务，处理三种数据类型

- 实现了批量处理优化，提升写入性能

- 设计了文件分帧缓存方案，解决复杂技术问题

  

**前端开发**：

- 使用Vue 3 + TypeScript开发前端应用

- 实现了数据可视化（ECharts图表）

- 优化了前端性能（代码分割、静态资源缓存）

  

**架构设计**：

- 设计了微服务架构，服务职责清晰

- 设计了数据流转方案，保证数据一致性

- 设计了缓存策略，提升查询性能

  

**DevOps实践**：

- 实现了Docker容器化部署

- 设计了离线部署方案，支持内网环境

- 优化了部署流程，提升部署效率

  

### 3. 技术思考的深度

  

**这个项目让我对以下技术有了更深刻的理解**：

  

**1. 消息队列的实践**

- **解耦**：数据源与系统解耦，提升系统灵活性

- **削峰**：通过批量处理，平滑处理高峰数据

- **可靠性**：通过重试机制，保证消息不丢失

  

**2. 并发编程的实践**

- **线程安全**：使用`ConcurrentHashMap`、`TreeMap`等线程安全的数据结构

- **内存管理**：缓存必须考虑过期和清理，避免内存泄漏

- **错误隔离**：不同业务场景需要不同的错误处理策略

  

**3. 微服务架构的实践**

- **服务拆分**：按业务职责拆分服务，保证服务独立性

- **数据一致性**：通过消息队列保证数据最终一致性

- **服务通信**：通过REST API和消息队列实现服务间通信

  

**4. 性能优化的实践**

- **批量处理**：减少数据库交互，提升写入性能

- **缓存策略**：合理使用缓存，提升查询性能

- **索引优化**：通过合理的索引设计，优化查询性能

  

---

  

## 📝 面试准备要点

  

### 快速回忆清单（面试前30秒）

1. **项目定位**：低压监测系统，微服务架构，实时数据处理

2. **技术栈**：Vue 3 + Spring Boot + MySQL + Docker

3. **核心亮点**：文件分帧传输、批量处理优化、离线部署方案

4. **个人贡献**：主导文件分帧传输模块设计实现，全栈开发

  

### 面试话术模板

  

**开场（项目背景）**：

"我负责开发了一个低压监测系统，这是一个基于微服务架构的实时设备监测平台。系统从华为云MQS消费设备数据，提供实时监测、历史查询、预警分析和负荷预测功能。"

  

**技术亮点（文件分帧传输）**：

"在项目中，我遇到的最大挑战是实现录波文件的分帧传输与自动拼接。文件通过MQS分帧传输，需要按序接收、拼接、校验。我设计并实现了一个基于`ConcurrentHashMap`和`TreeMap`的分帧缓存方案，支持乱序接收、自动过期清理，保证了文件完整性和线程安全。"

  

**全栈能力**：

"在这个项目中，我横跨前后端、架构、运维多个领域。后端实现了消息消费服务和批量处理优化，前端使用Vue 3实现了数据可视化，还设计了离线部署方案支持内网环境。"

  

---

  

## 📚 关键代码位置

  

### 后端核心代码

- `mqs-consumer/src/main/java/com/fr/pudong/mqs/handler/BatchMessageHandler.java` - 批量消息处理

- `mqs-consumer/src/main/java/com/fr/pudong/mqs/handler/FileTransferHandler.java` - 文件传输处理

- `mqs-consumer/src/main/java/com/fr/pudong/mqs/cache/FileFrameCache.java` - 分帧缓存实现

- `backend/src/main/java/com/example/backend/service/impl/DeviceServiceImpl.java` - 设备服务实现（含缓存）

  

### 前端核心代码

- `frontend/src/views/device/DeviceDetail.vue` - 设备详情页

- `frontend/src/views/device/DataReport.vue` - 数据报表（并发查询优化）

- `frontend/src/features/AnalogHistoryChart.vue` - 历史数据图表组件

  

### 配置文件

- `docker-compose.yml` - 在线部署配置

- `docker-compose.offline.yml` - 离线部署配置

- `frontend/nginx.conf` - Nginx配置（静态资源缓存）

  

---

  

*最后更新：2025年*