# 原码、反码、补码与 IEEE754
##整数的表示：补码
1. 现在计算机中所有有符号整数都使用补码存储；
2. 原理：
	1. 在 $N$ 位的二进制系统中，减去一个数等于加上这个数的补数。
3. 生成：
	1. 【正数的原、反、补都一致；
	2. ｜X｜的原码；
	3. 反码：将原码除了符号位外每一位都取反；
	4. 补码：反码+1
	5. ｜**表示形式**|**+1 (8-bit)**|**−1 (8-bit)**|
		|**原码**|`0000 0001`|`1000 0001`|
		|**反码**|`0000 0001`|`1111 1110`|
		|**补码**|`0000 0001`|`1111 1111`|
	
	6. 补码 -- 》 原码
		1. 正数：不变
		2. 负数：取反码（符号位 $1$ 不动，数值位取反），再+1.
		

4. 优点
	1. 统一了加法运算
	2. 唯一的零表示
		1. 原码：0000 和 1000
		2. 反码：0000 和 1000
		3. 补码：只有0000
	3. 多一位负数

## 浮点数的表示：IEEE754
1. 为什么浮点数运算（如 $0.1 + 0.2$）在计算机中往往不等于 $0.3$？
	1. 原理：计算机内部是二进制，大部分十进制小数（如 $0.1$ 和 $0.2$）无法被**精确地**表示为有限长度的二进制小数。
	2. 解决方案：使用 **定点数**（如 Java 的 `BigDecimal` 或 Go 的第三方高精度库）或**整数**（将金额单位转换为分）。
2. 大端序和小端序
	1. 解释字节序在内存中的存放顺序
	2. 大：高位字节在内存的低地址（像阅读习惯，从左到右）
	3. 小：（Intel、AMD、x86）
	4. TCP/IP 中规定网络字节序为大端序。

# Nginx
1. nginx的作用
	1. 反向代理：在高并发场景，可以在多个服务器上部署后端，前端发来的所有请求，经过nginx，负载均衡的分发给不同的后端。
	2. 网关：日志、压缩、限流、自定义
2. 实现 nginx.conf中定义
3. 单线程
	1. 用单线程来处理所有的网络连接，解决了并发问题；
4. 多进程
	1. 又称为worker进程
	2. 一个进程中有一个线程
	3. 多进程共享一个共享内存和磁盘弓箭（proxy cache）
5. 总结
	1. 支持动态配置
	2. 支持多种通用网关能力
	3. 支持多种网络协议
	4. 单master、多worker架构
	5. 对外提供一个ip端口
	6. 支持http服务和反向代理的高性能网关服务
6. 示例
	server {
	    listen 80;
	    server_name localhost;
	    root /usr/share/nginx/html;
	    index index.html;
	    # 前端路由支持
	    location / {
	        try_files $uri $uri/ /index.html;
	    }
	    # API代理到后端
	    location /api/ {
	        proxy_pass http://backend:8080/;
	        proxy_set_header Host $host;
	        proxy_set_header X-Real-IP $remote_addr;
	        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
	        proxy_set_header X-Forwarded-Proto $scheme;
	    }
	    # 静态资源缓存
	    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
	        expires 1y;
	        add_header Cache-Control "public, immutable";
	    }
	}


# redis
1. 高性能的**内存**数据库，常用于缓存、分布式锁、消息队列等，是后端最常用的中间件之一。
2. 全称：remote dictionary server 远程字典服务
3. **超高速** （亚毫秒级，全内存操作，是mysql的100~1000倍速度）的
4. **键值** （key-value：多种数据结构)数据库 
5. redis连接池
	1. 一组提前创建好的redis连接，由框架进行统一管理和复用；
	2. 避免频繁创建redis连接，提高性能。 





# 进程与线程
## 进程（process）
1. 操作系统进行资源分配和调度的基本单位
2. 核心特性
	1. 拥有独立的地址空间（内存），独立的文件描述符、独立的io通道等；
	2. 进程之间通信成本高，需要内核支持（管道、消息队列、共享内存），进行上下文切换
	3. 健壮性：一个进程奔溃不影响别的进程。
## 线程（thread）
1. CPU独立调度和执行的基本单位
2. 核心特性
	1. 同一进程中的所有线程共享地址空间、文件描述符等资源，是线程高效通信的基础。
	2. 线程之间通信只需要读写共享内存中的数据，很高效。
	3. 线程的创建、销毁和切换只需要对寄存器进行简单的恢复和保存，开销远小于进程。
	4. 多任务并发/并行的核心手段。
3. Executor 框架与线程池
	1. Java 最核心的线程管理机制是 `java.util.concurrent.Executor` 框架。
	2. 任务提交（用户）与线程执行（框架）的解耦；
4. 简单示例

```java
// 线程池初始化，线程池维护了4个保持alive的工作线程。
private static final ExecutorService executor = Executors.newFixedThreadPool(4);
// 任务提交，线程池查看是否有空闲线程，如果有就将这个任务分配给空闲线程；如果没有，任务就会被放入阻塞队列，等待线程来执行。
executor.execute(() -> { ... })


// 提交一个 Runnable 任务给线程池 
executor.execute(() -> { 
System.out.printf("线程 %s 正在处理任务 %d\n", Thread.currentThread().getName(), taskId); 
try { // 模拟耗时操作，如 I/O 或发送邮件 TimeUnit.MILLISECONDS.sleep(100); } 
catch (InterruptedException e) { Thread.currentThread().interrupt();
} 
});

//1. 定义一个 Callable 任务，它可以返回一个结果并抛出异常 
Callable<Integer> calculationTask = () -> { System.out.println("开始计算..."); TimeUnit.SECONDS.sleep(2); return 10 + 20; // 返回计算结果 30 
}; 
// 2. 提交任务并得到 Future 对象 
Future<Integer> futureResult = executor.submit(calculationTask);
```

1. 遇到的示例
	知识库系统中的基于本地文件系统的对象存储系统中：[[代码细读#^d400fc]]
	
### 用户级线程(User-Level Thread, ULT)
线程的创建、管理、调度、切换完全在**用户空间**中进行；
### 内核级线程(Kernel-Level Thread, KLT)
线程的管理、创建、调度和切换**全部**由**操作系统内核**完成和控制。


## 文件描述符（File Descriptor, FD）
1. ”一切皆文件“：系统将打开的文件、套接字（TC)、io资源等皆看作文件；
2. 文件描述符是操作系统为了管理这些 ”文件“ 而创建的一个非负整数句柄，是进程访问这些 ”文件“ 的唯一标识；
3. 每个进程有自己独立的文件描述符表；
4. 句柄作用：当进程调用 `open()`、`socket()` 等系统调用打开资源时，内核会返回一个 FD。进程后续对该资源的读写、控制等操作都通过这个 FD 进行；
5. 每个FD对应内核维护的一个数据结构，这个结构包含了文件的当前读写位置、访问模式、引用计数等关键信息。
6. 操作系统对单个进程能打开的FD有上限，ulimit -n可查看。

****

# 并发和并行
## 并发
宏观上多任务同时进行，微观上在单核cpu多任务在交替执行

## 并行
多任务在同一时刻在多核cpu上真正的同时进行


# 序列化和反序列化
- 序列化：将对象或者数据结构转化为可以存储或者传输的格式（字节流、json、xml等）
- 反序列化：将序列化后的数据还原。


# 数据库外键
- 外键指一个表中定义的一个字段，他引用了另一个表的主键，用于建立两个表之间的关系。
- 外键的作用是确保数据库中数据完整性，避免数据的孤立。
- 外键约束
	- **确保外键列的值必须存在于引用的主键列中**。
- 级联操作
	- 级联删除（CASCADE DELETE）：父表记录删，自动子表记录删
	- 级联更新（CASCADE UPDATE）：
	- 限制删除（RESTRICT）：如果子表中存在相关记录，则不能删除父表的记录
	- 置空（SET NULL）：附表记录删除时，子表记录的外键值置空

# 数据库  JOIN
- 用于按照某个关联条件将两张或者多张表横向组合的操作
	- 每张表提供一部分字段
	- 通过关联键决定是否匹配
	- 不同JOIN决定unmached（无法匹配的数据）是否保留。
- INNER JOIN 内连接
	- 返回两张表中匹配部分的部分，即“交集”。
	- 只有满足ON条件的记录才会被保留。
	- 两张表中任何一边没有匹配的记录都会被过滤掉。
```mysql
SELECT u.name, o.amount 
FROM users u 
INNER JOIN orders o ON u.id = o.user_id;
```
- LEFT JOIN 左连接
	- 左表中数据全部保留（若在右表没有匹配的数据，则用NULL填充右表字段；
	- 右表只保留匹配的记录。
```mysql
SELECT u.name, o.amount 
FROM users u 
LEFT JOIN orders o ON u.id = o.user_id;
```
- RIGHT JOIN 右连接
	- 返回右表全部数据
	- 左表只返回匹配的记录

# java项目启动
- SpringApplication.run() 启动 Spring Boot

- 扫描 @SpringBootApplication 下的组件

- 加载 application.yml 配置

- 创建 Spring 容器并完成依赖注入


# ConcurrentHashMap 、 TreeMap
